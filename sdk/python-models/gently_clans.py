#!/usr/bin/env python3
"""
gently_clans.py — Independent Clans + Collapse Model

THE DISTINCTION:
  Branch = FORKED from master (shared parent, inherits context)
  Clan   = INDEPENDENT (own starting context, added anytime)

  Branches DIVERGE from one point.
  Clans CONVERGE from many points.

WHAT TOM IS DESCRIBING:

  A project isn't just one master with forks.
  A project is a CONTAINER for many independent explorations (clans).
  Each clan starts with its OWN context — different prompts,
  different starting assumptions, different angles.

  They're not forks of each other. They're parallel, independent.

  Then at some point: COLLAPSE.
  Selected clans merge into a GROUP COLLECTION.
  The group collection opens in a THIRD pane.
  The third pane is the synthesis space.

THE THREE PANES:

  LEFT SHELF          CENTER (1 or 2 panes)       RIGHT SHELF
  ┌─────────┐        ┌──────────────────────┐     ┌──────────┐
  │ Project  │        │                      │     │ Artifacts│
  │ ├─ Clan A│◄──────►│  Active work area    │     │ + Groups │
  │ ├─ Clan B│        │  (any clan or group) │────►│          │
  │ ├─ Clan C│        │                      │     │ ⚙ auto   │
  │ │        │        ├──────────────────────┤     │          │
  │ ├─ Group │        │  Collapse view       │     │ Group    │
  │ │  (A+B) │◄──────►│  (third pane opens)  │     │ artifacts│
  │ │        │        │                      │     │          │
  │ └─ Clan D│        └──────────────────────┘     └──────────┘
  └─────────┘

HOW COLLAPSE WORKS:

  1. Tom has 3 clans running independently in a project:
     - Clan A: "blue channel math" (started with color theory context)
     - Clan B: "JPEG internals" (started with compression spec context)
     - Clan C: "gematria encoding" (started with Hebrew letter context)

  2. Tom selects Clan A + Clan B → COLLAPSE
  
  3. What happens:
     a. Both clans FREEZE (like tier promotion)
     b. A GROUP COLLECTION entity is created
     c. Auto-artifacts extracted from each clan:
        - Clan A's pin, gates, key findings
        - Clan B's pin, gates, key findings
     d. Third pane opens showing the GROUP
     e. Group has its OWN stamp combining both sources
     f. Group can have its OWN branches (sub-clans)
     g. The group IS a new clan — but one born from convergence

  4. The group's starting context is:
     "Here are findings from two independent explorations:
      [Clan A summary] + [Clan B summary]
      Synthesize these."

  5. Clan C is UNTOUCHED. Still running independently.
     It can be collapsed into the group later, or into a new group.

CLANS vs BRANCHES vs TIERS vs GROUPS:

  Clan    = independent origin, own context, parallel
  Branch  = forked from something, shared parent, divergent
  Tier    = master promoted, old master frozen, vertical
  Group   = clans collapsed together, convergent, synthesis

  A clan CAN have branches (it can fork internally).
  A group CAN have clans (sub-explorations from the synthesis).
  A group CAN be collapsed with other groups.
  It's recursive.

THE DATA MODEL:
"""

from dataclasses import dataclass, field
from datetime import datetime
from typing import Optional, List
from enum import Enum
import json


class ClanOrigin(Enum):
    INDEPENDENT = "independent"   # Started with own context
    COLLAPSED   = "collapsed"     # Born from collapsing other clans
    FORKED      = "forked"        # Branched from another clan


class ClanState(Enum):
    ACTIVE   = "active"
    FROZEN   = "frozen"     # Collapsed into a group
    HOLD     = "hold"       # Paused
    DONE     = "done"       # Concluded


class GateState(Enum):
    OPEN = "○"; HALF = "◐"; YES = "●"; NO = "✕"; REVISIT = "↺"


@dataclass
class Gate:
    letter: str
    question: str
    state: GateState = GateState.OPEN
    def sym(self): return f"{self.letter}{self.state.value}"


@dataclass
class ClanArtifact:
    """Auto-generated when a clan freezes during collapse."""
    id: str
    clan_id: str
    clan_name: str
    summary: str          # One-line conclusion
    findings: list        # Key points extracted
    gate_snapshot: list   # Gates at freeze time
    final_stamp: str
    depth: int
    auto: bool = True     # True = generated by collapse logic


@dataclass
class Clan:
    """
    An independent exploration within a project.
    Has its own starting context, its own depth, its own stamp.
    Can have sub-branches internally.
    Can be collapsed with other clans into a group.
    """
    id: str
    name: str
    origin: ClanOrigin
    starting_context: str     # What this clan was initialized with
    state: ClanState = ClanState.ACTIVE
    depth: int = 0
    pin: str = ""
    gates: list = field(default_factory=list)    # Clan-local gates
    branches: list = field(default_factory=list)  # Internal branches
    color: str = "#00e5a0"

    # If this clan was born from collapse:
    source_clan_ids: list = field(default_factory=list)
    
    # If this clan was forked from another:
    parent_clan_id: Optional[str] = None
    forked_at_depth: int = 0

    def make_stamp(self, project_id):
        gs = "".join(g.sym() for g in self.gates) if self.gates else ""
        ts = datetime.now().strftime("%m%dT%H%M")
        pin = self.pin[:25].replace(" ", "-") if self.pin else ""
        
        origin_tag = ""
        if self.origin == ClanOrigin.COLLAPSED:
            sources = "+".join(self.source_clan_ids[:3])
            origin_tag = f"\u2B50{sources}"  # ⭐ marks collapsed origin
        elif self.origin == ClanOrigin.FORKED:
            origin_tag = f"\u2B06{self.parent_clan_id}@d{self.forked_at_depth}"

        parts = [
            "OLO",
            f"\U0001F33F{project_id}/{self.id}",
            f"\U0001F4CD{self.depth}",
            f"\u26A1{self.state.value}",
        ]
        if gs:
            parts.append(f"\U0001F512{gs}")
        if pin:
            parts.append(f"\U0001F4CC{pin}")
        if origin_tag:
            parts.append(origin_tag)
        parts.append(f"\u23F1{ts}")
        return "[" + "|".join(p for p in parts if p) + "]"

    def summary_line(self):
        state_sym = {'active': '\u25C6', 'frozen': '\u2744', 'hold': '\u23F8', 'done': '\u25CF'}
        origin_sym = {'independent': '\u2022', 'collapsed': '\u2B50', 'forked': '\u2192'}
        return (
            f"{state_sym.get(self.state.value, '?')} "
            f"{origin_sym.get(self.origin.value, '?')} "
            f"{self.name} [d={self.depth}] "
            f"\"{self.pin}\""
        )


@dataclass
class GroupCollection:
    """
    Created when clans collapse together.
    Contains auto-artifacts from each source clan.
    Has its own identity — can be worked in the third pane.
    Is itself a special kind of clan (recursive).
    """
    id: str
    name: str
    source_clan_ids: list         # Which clans were collapsed
    artifacts: list = field(default_factory=list)  # ClanArtifacts
    synthesis_clan: Optional[Clan] = None  # The new clan born from this

    def build_synthesis_context(self):
        """Generate the starting context for the synthesis clan."""
        lines = [
            f"=== GROUP COLLECTION: {self.name} ===",
            f"This synthesis combines {len(self.source_clan_ids)} independent explorations.",
            "",
        ]
        for art in self.artifacts:
            lines.append(f"--- From: {art.clan_name} (depth {art.depth}) ---")
            lines.append(f"Summary: {art.summary}")
            if art.findings:
                lines.append("Key findings:")
                for f in art.findings:
                    lines.append(f"  \u2022 {f}")
            lines.append(f"Gates: {' '.join(g['letter'] + g['state'] for g in art.gate_snapshot)}")
            lines.append("")

        lines.append("=== SYNTHESIZE THESE EXPLORATIONS ===")
        lines.append("What connections exist? What conflicts? What emerges?")
        return "\n".join(lines)


@dataclass
class Project:
    id: str
    name: str
    color: str
    clans: list = field(default_factory=list)     # All clans (active, frozen, done)
    groups: list = field(default_factory=list)     # All group collections
    project_gates: list = field(default_factory=list)  # Project-level gates

    def add_clan(self, name, starting_context, color=None, gates=None):
        """Add a new independent clan to the project."""
        clan = Clan(
            id=f"clan-{len(self.clans)}-{name.lower().replace(' ', '-')}",
            name=name,
            origin=ClanOrigin.INDEPENDENT,
            starting_context=starting_context,
            color=color or self.color,
            gates=gates or [],
        )
        self.clans.append(clan)
        return clan

    def fork_clan(self, source_clan_id, name, color=None):
        """Fork a new clan from an existing one (branch-like but as full clan)."""
        source = self._get_clan(source_clan_id)
        if not source:
            return None

        clan = Clan(
            id=f"clan-{len(self.clans)}-{name.lower().replace(' ', '-')}",
            name=name,
            origin=ClanOrigin.FORKED,
            starting_context=f"Forked from {source.name} at depth {source.depth}.\n{source.pin}",
            color=color or source.color,
            gates=[Gate(g.letter, g.question, g.state) for g in source.gates],
            parent_clan_id=source_clan_id,
            forked_at_depth=source.depth,
        )
        self.clans.append(clan)
        return clan

    def collapse(self, clan_ids: list, group_name: str) -> GroupCollection:
        """
        COLLAPSE: The convergence operation.

        Takes multiple independent clans and:
        1. Freezes each one
        2. Extracts auto-artifacts from each
        3. Creates a GroupCollection
        4. Spawns a synthesis clan with combined context
        5. Returns the group (which opens in third pane)
        """
        source_clans = [self._get_clan(cid) for cid in clan_ids]
        source_clans = [c for c in source_clans if c is not None]

        if len(source_clans) < 2:
            return None

        group = GroupCollection(
            id=f"group-{len(self.groups)}-{group_name.lower().replace(' ', '-')}",
            name=group_name,
            source_clan_ids=clan_ids,
        )

        # ─── Freeze each clan and extract artifacts ───
        for clan in source_clans:
            clan.state = ClanState.FROZEN

            art = ClanArtifact(
                id=f"cart-{clan.id}",
                clan_id=clan.id,
                clan_name=clan.name,
                summary=clan.pin,
                findings=self._extract_findings(clan),
                gate_snapshot=[{'letter': g.letter, 'question': g.question, 'state': g.state.value} for g in clan.gates],
                final_stamp=clan.make_stamp(self.id),
                depth=clan.depth,
            )
            group.artifacts.append(art)

        # ─── Create synthesis clan ───
        synthesis = Clan(
            id=f"clan-{len(self.clans)}-synth-{group_name.lower().replace(' ', '-')}",
            name=f"\u2B50 {group_name}",
            origin=ClanOrigin.COLLAPSED,
            starting_context=group.build_synthesis_context(),
            color="#c77dff",  # Purple for synthesis
            source_clan_ids=clan_ids,
        )
        # Synthesis inherits gates from all sources (merge unique)
        seen_letters = set()
        for clan in source_clans:
            for g in clan.gates:
                if g.letter not in seen_letters:
                    synthesis.gates.append(Gate(g.letter, g.question, g.state))
                    seen_letters.add(g.letter)

        group.synthesis_clan = synthesis
        self.clans.append(synthesis)
        self.groups.append(group)

        return group

    def _get_clan(self, clan_id):
        return next((c for c in self.clans if c.id == clan_id), None)

    def _extract_findings(self, clan):
        """Extract key findings from a clan. In real app, this parses the DOM/conversation."""
        findings = []
        if clan.pin:
            findings.append(clan.pin)
        for b in clan.branches:
            if b.get('pin', ''):
                findings.append(f"(branch {b.get('name', '?')}): {b['pin']}")
        return findings

    def active_clans(self):
        return [c for c in self.clans if c.state == ClanState.ACTIVE]

    def frozen_clans(self):
        return [c for c in self.clans if c.state == ClanState.FROZEN]

    def tree_display(self):
        """What the left shelf shows."""
        lines = []
        lines.append(f"\u25C6 {self.name}")
        lines.append(f"\u2502")

        # Active clans
        active = self.active_clans()
        if active:
            for i, c in enumerate(active):
                is_last = (i == len(active) - 1) and not self.groups
                connector = "\u2514" if is_last else "\u251C"
                lines.append(f"{connector}\u2500\u2500 {c.summary_line()}")
                if c.origin == ClanOrigin.COLLAPSED:
                    lines.append(f"\u2502   \u2514\u2500 from: {', '.join(c.source_clan_ids)}")

        # Groups (with their frozen source clans nested)
        for gi, group in enumerate(self.groups):
            is_last_group = (gi == len(self.groups) - 1)
            connector = "\u2514" if is_last_group else "\u251C"
            lines.append(f"{connector}\u2500\u2500 \u2B50 GROUP: {group.name}")
            
            # Show the synthesis clan
            if group.synthesis_clan:
                lines.append(f"\u2502   \u251C\u2500\u2500 {group.synthesis_clan.summary_line()}")
            
            # Show frozen source clans
            for si, art in enumerate(group.artifacts):
                is_last_src = (si == len(group.artifacts) - 1)
                sc = "\u2514" if is_last_src else "\u251C"
                source_clan = self._get_clan(art.clan_id)
                if source_clan:
                    lines.append(f"\u2502   {sc}\u2500\u2500 {source_clan.summary_line()}")
                    lines.append(f"\u2502   \u2502   \u2514\u2500 \u2699 auto: \"{art.summary}\"")

        return "\n".join(lines)


# ═══════════════════════════════════════
# DEMO
# ═══════════════════════════════════════

if __name__ == "__main__":
    SEP = "=" * 64

    print(SEP)
    print("  GENTLY CLANS — Independent Origins + Collapse")
    print(SEP)
    print()

    proj = Project(id="olo", name="OLO Guard", color="#00e5a0")

    # ─── Add independent clans (different starting contexts) ───
    print("\u25B8 ADDING INDEPENDENT CLANS")
    print("-" * 40)
    print()

    clan_a = proj.add_clan(
        "Blue Channel Math",
        "Starting context: Color theory, RGB color spaces, "
        "channel isolation techniques, subpixel rendering.",
        color="#00e5a0",
        gates=[Gate('A', 'Blue survives compression?'), Gate('B', 'Blue detectable post-JPEG?')],
    )
    clan_a.depth = 8
    clan_a.pin = "blue channel verified as carrier"
    clan_a.gates[0].state = GateState.YES
    clan_a.gates[1].state = GateState.HALF
    print(f"  {clan_a.summary_line()}")
    print(f"  context: color theory, RGB...")
    print(f"  stamp: {clan_a.make_stamp(proj.id)}")
    print()

    clan_b = proj.add_clan(
        "JPEG Internals",
        "Starting context: JPEG specification, DCT transform, "
        "quantization tables, chroma subsampling 4:2:0 / 4:4:4.",
        color="#4d9fff",
        gates=[Gate('C', 'Quantization predictable?'), Gate('D', 'Subsampling exploitable?')],
    )
    clan_b.depth = 6
    clan_b.pin = "4:2:0 subsampling destroys 75% chroma"
    clan_b.gates[0].state = GateState.YES
    clan_b.gates[1].state = GateState.YES
    print(f"  {clan_b.summary_line()}")
    print(f"  context: JPEG spec, DCT, quantization...")
    print(f"  stamp: {clan_b.make_stamp(proj.id)}")
    print()

    clan_c = proj.add_clan(
        "Gematria Encoding",
        "Starting context: Hebrew letter values, 72 Names, "
        "boustrophedon writing, multi-script transliteration.",
        color="#ffd93d",
        gates=[Gate('E', 'Gematria fits in blue channel?'), Gate('F', 'Visual detection possible?')],
    )
    clan_c.depth = 5
    clan_c.pin = "72 Names map to byte sequences"
    clan_c.gates[0].state = GateState.HALF
    print(f"  {clan_c.summary_line()}")
    print(f"  context: Hebrew letters, 72 Names...")
    print(f"  stamp: {clan_c.make_stamp(proj.id)}")
    print()

    clan_d = proj.add_clan(
        "Adversarial Testing",
        "Starting context: Image forensics, steganography detection, "
        "ML classifiers for hidden content, social media re-encoding.",
        color="#ff6b35",
        gates=[Gate('G', 'Survives Twitter re-encode?'), Gate('H', 'ML detectable?')],
    )
    clan_d.depth = 3
    clan_d.pin = "Twitter strips metadata but preserves pixels"
    print(f"  {clan_d.summary_line()}")
    print(f"  context: forensics, stego detection...")
    print(f"  stamp: {clan_d.make_stamp(proj.id)}")
    print()

    # ─── Current left shelf state ───
    print(SEP)
    print("  LEFT SHELF — Before Collapse")
    print(SEP)
    print()
    print(proj.tree_display())
    print()
    print("  Each clan is INDEPENDENT. Different starting contexts.")
    print("  They don't know about each other.")
    print("  Now Tom sees that A + B should converge...")
    print()

    # ─── COLLAPSE A + B ───
    print(SEP)
    print("  COLLAPSING Clan A + Clan B")
    print(SEP)
    print()

    group1 = proj.collapse(
        [clan_a.id, clan_b.id],
        "Blue + JPEG Synthesis"
    )

    print("  What just happened:")
    print()
    print(f"  1. Clan A (Blue Channel Math) \u2192 \u2744 FROZEN")
    print(f"  2. Clan B (JPEG Internals)    \u2192 \u2744 FROZEN")
    print(f"  3. Auto-artifacts extracted from each:")
    for art in group1.artifacts:
        print(f"     \u2699 {art.clan_name}: \"{art.summary}\"")
        print(f"        gates: {' '.join(g['letter']+g['state'] for g in art.gate_snapshot)}")
    print()
    print(f"  4. Group Collection created: \"{group1.name}\"")
    print(f"  5. Synthesis clan spawned: \"{group1.synthesis_clan.name}\"")
    print(f"     origin: {group1.synthesis_clan.origin.value}")
    print(f"     stamp: {group1.synthesis_clan.make_stamp(proj.id)}")
    print()
    print(f"  6. Synthesis starting context (what third pane Claude sees):")
    print()
    context = group1.build_synthesis_context()
    for line in context.split('\n'):
        print(f"     {line}")
    print()

    # ─── Clan C still running independently ───
    print(f"  7. Clan C (\"{clan_c.name}\") UNTOUCHED: {clan_c.state.value}")
    print(f"     Clan D (\"{clan_d.name}\") UNTOUCHED: {clan_d.state.value}")
    print()

    # ─── Updated left shelf ───
    print(SEP)
    print("  LEFT SHELF — After Collapse")
    print(SEP)
    print()
    print(proj.tree_display())
    print()

    # ─── Now collapse the synthesis + Clan C ───
    print(SEP)
    print("  SECOND COLLAPSE: Synthesis + Clan C")
    print(SEP)
    print()
    print("  The synthesis clan did its work, found connections.")
    synth = group1.synthesis_clan
    synth.depth = 4
    synth.pin = "blue channel + JPEG = steganographic kill switch"
    synth.gates[0].state = GateState.YES  # A from clan A
    synth.gates[1].state = GateState.YES  # B from clan A
    synth.gates[2].state = GateState.YES  # C from clan B
    synth.gates[3].state = GateState.YES  # D from clan B

    # Collapse synthesis + gematria
    group2 = proj.collapse(
        [synth.id, clan_c.id],
        "Guard + Gematria Unified"
    )

    print(f"  Synthesis clan \u2192 \u2744 FROZEN")
    print(f"  Clan C (Gematria) \u2192 \u2744 FROZEN")
    print(f"  New synthesis: \"{group2.synthesis_clan.name}\"")
    print(f"  stamp: {group2.synthesis_clan.make_stamp(proj.id)}")
    print()

    # ─── Final state ───
    print(SEP)
    print("  FINAL LEFT SHELF")
    print(SEP)
    print()
    print(proj.tree_display())
    print()

    print(SEP)
    print("  RIGHT SHELF (auto-artifacts from all collapses)")
    print(SEP)
    print()
    for group in proj.groups:
        print(f"  \u2B50 {group.name}")
        for art in group.artifacts:
            print(f"    \u2699 {art.clan_name} \u2192 \"{art.summary}\"")
            print(f"       depth={art.depth} gates={' '.join(g['letter']+g['state'] for g in art.gate_snapshot)}")
        print()

    # ─── Three-pane state ───
    print(SEP)
    print("  THE THREE PANES")
    print(SEP)
    print()
    print("  LEFT:   Project tree with clans + groups + frozen history")
    print(f"  CENTER: \u2B50 {group2.synthesis_clan.name} (synthesis, third pane)")
    print(f"  RIGHT:  Adversarial Testing (still independent, still active)")
    print()
    print("  Clan D is untouched. It can:")
    print("  \u2022 Keep running independently")
    print("  \u2022 Be collapsed into the unified group later")
    print("  \u2022 Fork into sub-clans of its own")
    print("  \u2022 Stay as reference while synthesis continues")
    print()

    # ─── Visual tree ───
    print(SEP)
    print("  FULL TREE VISUALIZATION")
    print(SEP)
    print()
    print("  \u25C6 OLO Guard")
    print("  \u2502")
    print("  \u251C\u2500\u2500 \u25C6 \u2022 Adversarial Testing [ACTIVE, d=3]")
    print("  \u2502   independent, still running")
    print("  \u2502")
    print("  \u251C\u2500\u2500 \u2B50 GROUP: Guard + Gematria Unified")
    print("  \u2502   \u251C\u2500\u2500 \u25C6 \u2B50 Synthesis [ACTIVE] (THIRD PANE)")
    print("  \u2502   \u2502   stamp carries \u2B50synth-blue+JPEG+gematria")
    print("  \u2502   \u2502")
    print("  \u2502   \u251C\u2500\u2500 \u2744 \u2B50 Blue + JPEG Synthesis [FROZEN]")
    print("  \u2502   \u2502   pin: \"blue channel + JPEG = kill switch\"")
    print("  \u2502   \u2502   \u2514\u2500 \u2699 auto-artifact")
    print("  \u2502   \u2502")
    print("  \u2502   \u2514\u2500\u2500 \u2744 \u2022 Gematria Encoding [FROZEN]")
    print("  \u2502       pin: \"72 Names map to byte sequences\"")
    print("  \u2502       \u2514\u2500 \u2699 auto-artifact")
    print("  \u2502")
    print("  \u2514\u2500\u2500 \u2B50 GROUP: Blue + JPEG Synthesis")
    print("      \u251C\u2500\u2500 \u2744 \u2022 Blue Channel Math [FROZEN]")
    print("      \u2502   pin: \"blue channel verified as carrier\"")
    print("      \u2502   \u2514\u2500 \u2699 auto-artifact")
    print("      \u2502")
    print("      \u2514\u2500\u2500 \u2744 \u2022 JPEG Internals [FROZEN]")
    print("          pin: \"4:2:0 subsampling destroys 75% chroma\"")
    print("          \u2514\u2500 \u2699 auto-artifact")
    print()
    print("  Every \u2699 is an artifact that EXISTS BY LOGIC.")
    print("  Every \u2B50 is a convergence that creates its own scope.")
    print("  The tree grows upward (synthesis) and outward (independence).")
    print()
    print(SEP)
    print("  CLAN/COLLAPSE MODEL VALIDATED")
    print(SEP)
