<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>OLO — Adversarial Display Layer</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  
  body {
    background: #000;
    color: #0f0;
    font-family: 'Courier New', monospace;
    min-height: 100vh;
    overflow-x: hidden;
  }

  .container {
    max-width: 900px;
    margin: 0 auto;
    padding: 20px;
  }

  h1 {
    text-align: center;
    font-size: 14px;
    color: #444;
    margin-bottom: 30px;
    letter-spacing: 4px;
  }

  /* ============================================
     OLO CORE: Green/Blue channel splitting
     Green = human readable (high cone sensitivity)
     Blue = adversarial layer (compression-hostile)
     ============================================ */

  .olo-display {
    position: relative;
    padding: 30px;
    border: 1px solid #0a3a0a;
    margin: 20px 0;
    background: #000;
    overflow: hidden;
  }

  .olo-display::before {
    content: '';
    position: absolute;
    top: 0; left: 0; right: 0; bottom: 0;
    /* Subtle blue noise pattern - visible on screen, killed by compression */
    background: 
      repeating-linear-gradient(
        0deg,
        transparent,
        transparent 2px,
        rgba(0, 0, 80, 0.03) 2px,
        rgba(0, 0, 80, 0.03) 4px
      );
    pointer-events: none;
    z-index: 1;
  }

  /* ============================================
     LAYER 1: Green channel — primary text
     Human-visible, high readability
     ============================================ */
  .green-layer {
    color: #00ff41;
    font-size: 24px;
    line-height: 1.8;
    letter-spacing: 3px;
    position: relative;
    z-index: 2;
    /* Subpixel rendering hint */
    -webkit-font-smoothing: none;
    text-rendering: geometricPrecision;
  }

  /* ============================================
     LAYER 2: Blue channel — verification/adversarial
     Visible on live display, degrades on capture
     ============================================ */
  .blue-layer {
    color: rgba(30, 30, 255, 0.65);
    font-size: 24px;
    line-height: 1.8;
    letter-spacing: 3px;
    position: absolute;
    z-index: 3;
    /* Offset creates moiré with green — screen-only effect */
    transform: translate(1px, 0px);
    -webkit-font-smoothing: none;
    text-rendering: geometricPrecision;
    mix-blend-mode: screen;
  }

  /* ============================================
     LAYER 3: OLO glyphs — palindrome markers
     Green O's with Blue L — the key pattern
     ============================================ */
  .olo-glyph {
    display: inline-block;
    position: relative;
  }
  
  .olo-glyph .o-char {
    color: #00ff41;
    text-shadow: 0 0 2px rgba(0, 255, 65, 0.3);
  }
  
  .olo-glyph .l-char {
    color: rgba(40, 40, 255, 0.7);
    text-shadow: 0 0 1px rgba(40, 40, 255, 0.2);
    /* The L lives primarily in blue channel — screenshot hostile */
  }

  /* ============================================
     BOUSTROPHEDON LINE ALTERNATION
     Even lines are RTL, odd lines are LTR
     ============================================ */
  .line-ltr {
    direction: ltr;
    text-align: left;
  }

  .line-rtl {
    direction: rtl;
    text-align: right;
    unicode-bidi: bidi-override;
  }

  /* ============================================
     SCRIPT MIXING — Greek/Hebrew/Latin interleave
     ============================================ */
  .script-greek  { font-family: 'Courier New', monospace; color: #00ff41; }
  .script-latin  { font-family: 'Courier New', monospace; color: #00dd33; }
  .script-hebrew { font-family: 'Courier New', monospace; color: rgba(30, 120, 255, 0.75); }

  /* ============================================
     TEMPORAL FRAGMENTATION
     Rolling display — full message never on screen at once
     ============================================ */
  .temporal-fragment {
    opacity: 0;
    animation: fragment-cycle 4s infinite;
  }

  .temporal-fragment:nth-child(1) { animation-delay: 0s; }
  .temporal-fragment:nth-child(2) { animation-delay: 1s; }
  .temporal-fragment:nth-child(3) { animation-delay: 2s; }
  .temporal-fragment:nth-child(4) { animation-delay: 3s; }

  @keyframes fragment-cycle {
    0%   { opacity: 0; }
    10%  { opacity: 1; }
    25%  { opacity: 1; }
    35%  { opacity: 0; }
    100% { opacity: 0; }
  }

  /* ============================================
     ADVERSARIAL NOISE LAYER
     Subtle patterns that disrupt CLIP/ViT features
     without affecting human readability
     ============================================ */
  .adversarial-noise {
    position: absolute;
    top: 0; left: 0; right: 0; bottom: 0;
    z-index: 4;
    pointer-events: none;
    opacity: 0.04;
    mix-blend-mode: overlay;
    /* CSS noise approximation */
    background-image: 
      radial-gradient(circle at 20% 50%, rgba(0,0,255,0.15) 0%, transparent 50%),
      radial-gradient(circle at 80% 50%, rgba(0,0,200,0.1) 0%, transparent 50%),
      repeating-conic-gradient(
        rgba(0,0,255,0.05) 0deg,
        transparent 1deg,
        transparent 3deg,
        rgba(0,0,255,0.05) 4deg
      );
    animation: noise-shift 0.1s infinite;
  }

  @keyframes noise-shift {
    0%   { transform: translate(0, 0); }
    25%  { transform: translate(-1px, 1px); }
    50%  { transform: translate(1px, -1px); }
    75%  { transform: translate(-1px, -1px); }
    100% { transform: translate(0, 0); }
  }

  /* ============================================
     GEMATRIA VERIFICATION DISPLAY
     ============================================ */
  .gematria-panel {
    border: 1px solid #0a2a4a;
    padding: 20px;
    margin: 20px 0;
    background: rgba(0, 0, 30, 0.3);
    font-size: 12px;
  }

  .gematria-value {
    font-size: 48px;
    font-weight: bold;
    text-align: center;
    /* Value rendered in blue channel only */
    color: rgba(0, 30, 255, 0.6);
    text-shadow: 0 0 20px rgba(0, 30, 255, 0.15);
    letter-spacing: 10px;
    margin: 10px 0;
  }

  .gematria-bar {
    height: 4px;
    background: linear-gradient(90deg, 
      #00ff41 0%, 
      #00ff41 var(--green-pct), 
      rgba(30, 30, 255, 0.6) var(--green-pct), 
      rgba(30, 30, 255, 0.6) 100%
    );
    margin: 8px 0;
    border-radius: 2px;
  }

  .section-label {
    color: #444;
    font-size: 10px;
    letter-spacing: 3px;
    text-transform: uppercase;
    margin: 25px 0 10px;
  }

  /* ============================================
     SUBPIXEL WARFARE
     Exploits LCD subpixel layout (RGB stripe)
     Content rendered at subpixel level doesn't
     survive screenshot → resize pipeline
     ============================================ */
  .subpixel-text {
    font-size: 8px;
    letter-spacing: 0px;
    /* Force subpixel rendering */
    -webkit-font-smoothing: subpixel-antialiased;
    -moz-osx-font-smoothing: auto;
    transform: scaleX(0.33);
    transform-origin: left;
    color: rgba(0, 100, 255, 0.5);
    white-space: nowrap;
  }

  /* ============================================
     DEMO CONTROLS
     ============================================ */
  .controls {
    display: flex;
    gap: 10px;
    margin: 20px 0;
    flex-wrap: wrap;
  }

  .controls button {
    background: #111;
    color: #00ff41;
    border: 1px solid #0a3a0a;
    padding: 8px 16px;
    font-family: 'Courier New', monospace;
    font-size: 12px;
    cursor: pointer;
    transition: all 0.2s;
  }

  .controls button:hover {
    background: #0a2a0a;
    border-color: #00ff41;
  }

  .controls button.active {
    background: #0a3a0a;
    border-color: #00ff41;
    box-shadow: 0 0 10px rgba(0, 255, 65, 0.2);
  }

  input[type="text"] {
    background: #0a0a0a;
    color: #00ff41;
    border: 1px solid #0a3a0a;
    padding: 10px 16px;
    font-family: 'Courier New', monospace;
    font-size: 16px;
    width: 100%;
    margin: 10px 0;
    outline: none;
  }

  input[type="text"]:focus {
    border-color: #00ff41;
    box-shadow: 0 0 10px rgba(0, 255, 65, 0.1);
  }

  .explanation {
    color: #333;
    font-size: 10px;
    line-height: 1.6;
    margin: 5px 0;
    letter-spacing: 1px;
  }

  .channel-demo {
    display: grid;
    grid-template-columns: 1fr 1fr 1fr;
    gap: 15px;
    margin: 15px 0;
  }

  .channel-box {
    padding: 15px;
    text-align: center;
    border: 1px solid #111;
    font-size: 20px;
    letter-spacing: 5px;
  }

  .channel-r { background: rgba(40, 0, 0, 0.3); color: rgba(255, 0, 0, 0.7); }
  .channel-g { background: rgba(0, 20, 0, 0.3); color: #00ff41; }
  .channel-b { background: rgba(0, 0, 40, 0.3); color: rgba(60, 60, 255, 0.7); }

  .comparison {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 20px;
    margin: 20px 0;
  }

  .comp-box {
    padding: 20px;
    border: 1px solid #111;
  }

  .comp-label {
    font-size: 10px;
    color: #444;
    letter-spacing: 2px;
    margin-bottom: 10px;
  }

  /* Simulated screenshot degradation */
  .degraded {
    filter: blur(0.5px) contrast(0.9);
    /* Simulate JPEG blue channel loss */
  }
  .degraded .blue-layer,
  .degraded .l-char,
  .degraded .script-hebrew,
  .degraded .gematria-value,
  .degraded .adversarial-noise {
    opacity: 0.1 !important;
    filter: blur(2px);
  }
  .degraded .subpixel-text {
    opacity: 0 !important;
  }
</style>
</head>
<body>

<div class="container">
  <h1>O L O &nbsp; — &nbsp; A D V E R S A R I A L &nbsp; D I S P L A Y &nbsp; L A Y E R</h1>

  <!-- Input -->
  <input type="text" id="input" placeholder="Enter instruction..." value="e pluribus unum" />
  
  <div class="controls">
    <button id="btn-render" class="active" onclick="render()">⟁ RENDER OLO</button>
    <button id="btn-temporal" onclick="toggleTemporal()">◑ TEMPORAL MODE</button>
    <button id="btn-degrade" onclick="toggleDegrade()">◧ SIMULATE CAPTURE</button>
    <button id="btn-boustro" onclick="toggleBoustro()">⇄ BOUSTROPHEDON</button>
  </div>

  <!-- RGB Channel Isolation Demo -->
  <div class="section-label">channel isolation — what the AI sees vs what you see</div>
  <div class="channel-demo">
    <div class="channel-box channel-r">
      <div id="ch-r">O L O</div>
      <div class="explanation">RED — empty carrier</div>
    </div>
    <div class="channel-box channel-g">
      <div id="ch-g">O L O</div>
      <div class="explanation">GREEN — human readable</div>
    </div>
    <div class="channel-box channel-b">
      <div id="ch-b">O L O</div>
      <div class="explanation">BLUE — verification (dies on capture)</div>
    </div>
  </div>

  <!-- Live vs Captured comparison -->
  <div class="section-label">live display vs screenshot extraction</div>
  <div class="comparison">
    <div class="comp-box" id="live-box">
      <div class="comp-label">◉ LIVE DISPLAY (what you see)</div>
      <div id="live-display"></div>
    </div>
    <div class="comp-box degraded" id="captured-box">
      <div class="comp-label">◧ AFTER CAPTURE (what AI extracts)</div>
      <div id="captured-display"></div>
    </div>
  </div>

  <!-- Main OLO Display -->
  <div class="section-label">olo adversarial render</div>
  <div class="olo-display" id="main-display">
    <div class="adversarial-noise" id="noise-layer"></div>
    <div id="render-output"></div>
  </div>

  <!-- Gematria Verification -->
  <div class="section-label">gematria verification channel (blue only)</div>
  <div class="gematria-panel">
    <div class="gematria-value" id="gematria-num">—</div>
    <div id="gematria-bars"></div>
    <div class="explanation" id="gematria-info"></div>
  </div>

  <!-- Subpixel layer -->
  <div class="section-label">subpixel verification (visible on LCD, invisible on capture)</div>
  <div style="overflow: hidden; height: 20px; position: relative;">
    <div class="subpixel-text" id="subpixel-output"></div>
  </div>
</div>

<script>
// ============================================================
// TRANSLITERATION MAPS
// ============================================================
const ENG_TO_GREEK = {
  'a':'α','b':'β','c':'κ','d':'δ','e':'ε','f':'φ','g':'γ','h':'η',
  'i':'ι','j':'ξ','k':'κ','l':'λ','m':'μ','n':'ν','o':'ο','p':'π',
  'q':'κ','r':'ρ','s':'σ','t':'τ','u':'υ','v':'β','w':'ω','x':'ξ',
  'y':'ψ','z':'ζ',' ':' ','th':'θ','ph':'φ','ch':'χ','ps':'ψ'
};

const ENG_TO_HEBREW = {
  'a':'א','b':'ב','c':'כ','d':'ד','e':'א','f':'פ','g':'ג','h':'ה',
  'i':'י','j':'ג','k':'כ','l':'ל','m':'מ','n':'נ','o':'ע','p':'פ',
  'q':'ק','r':'ר','s':'ס','t':'ת','u':'ו','v':'ו','w':'ו','x':'קס',
  'y':'י','z':'ז',' ':' ','sh':'ש','ch':'ח','th':'ת','tz':'צ'
};

const ENG_TO_LATIN = {
  'a':'A','b':'B','c':'C','d':'D','e':'E','f':'F','g':'G','h':'H',
  'i':'I','j':'I','k':'C','l':'L','m':'M','n':'N','o':'O','p':'P',
  'q':'Q','r':'R','s':'S','t':'T','u':'V','v':'V','w':'VV','x':'X',
  'y':'Y','z':'Z',' ':' '
};

const HEBREW_VALUES = {
  'א':1,'ב':2,'ג':3,'ד':4,'ה':5,'ו':6,'ז':7,'ח':8,'ט':9,'י':10,
  'כ':20,'ל':30,'מ':40,'נ':50,'ס':60,'ע':70,'פ':80,'צ':90,'ק':100,
  'ר':200,'ש':300,'ת':400
};

const GREEK_VALUES = {
  'α':1,'β':2,'γ':3,'δ':4,'ε':5,'ζ':7,'η':8,'θ':9,'ι':10,'κ':20,
  'λ':30,'μ':40,'ν':50,'ξ':60,'ο':70,'π':80,'ρ':100,'σ':200,'τ':300,
  'υ':400,'φ':500,'χ':600,'ψ':700,'ω':800
};

const SEPHIROT = {
  1:'Keter (Crown)',2:'Chokmah (Wisdom)',3:'Binah (Understanding)',
  4:'Chesed (Mercy)',5:'Gevurah (Severity)',6:'Tiferet (Beauty)',
  7:'Netzach (Victory)',8:'Hod (Splendor)',9:'Yesod (Foundation)'
};

// ============================================================
// TRANSLITERATION ENGINE
// ============================================================
function transliterate(text, map) {
  text = text.toLowerCase();
  let result = [];
  let i = 0;
  while (i < text.length) {
    if (i + 1 < text.length) {
      const di = text.substring(i, i + 2);
      if (map[di]) { result.push(map[di]); i += 2; continue; }
    }
    result.push(map[text[i]] || text[i]);
    i++;
  }
  return result.join('');
}

function calcGematria(text, values) {
  return [...text].reduce((sum, ch) => sum + (values[ch] || 0), 0);
}

function reduceToSingle(n) {
  while (n > 9) n = [...String(n)].reduce((s, d) => s + parseInt(d), 0);
  return n;
}

// ============================================================
// OLO RENDERING ENGINE
// ============================================================
let temporalMode = false;
let boustroMode = false;
let degradeMode = false;

function render() {
  const input = document.getElementById('input').value;
  if (!input) return;

  const greek = transliterate(input, ENG_TO_GREEK);
  const hebrew = transliterate(input, ENG_TO_HEBREW);
  const latin = transliterate(input, ENG_TO_LATIN);
  
  const greekVal = calcGematria(greek, GREEK_VALUES);
  const hebrewVal = calcGematria(hebrew, HEBREW_VALUES);
  const latinVal = [...latin.toLowerCase()].reduce((s, c) => {
    const code = c.charCodeAt(0);
    return s + (code >= 97 && code <= 122 ? code - 96 : 0);
  }, 0);

  const total = greekVal + latinVal + hebrewVal;
  const totalRed = reduceToSingle(total);
  const hebrewRed = reduceToSingle(hebrewVal);
  const greekRed = reduceToSingle(greekVal);

  // Channel demo
  document.getElementById('ch-g').textContent = greek;
  document.getElementById('ch-b').textContent = hebrew.split('').reverse().join('');
  document.getElementById('ch-r').textContent = '·'.repeat(greek.length);

  // Build OLO multi-layer display
  const layers = [
    { script: 'greek', text: greek, dir: 'ltr', label: 'ΕΛΛΗΝΙΚΑ →' },
    { script: 'latin', text: latin, dir: 'ltr', label: 'LATINA →' },
    { script: 'greek', text: greek.split('').reverse().join(''), dir: 'rtl', label: '← ΑΡΧΑΪΚΑ' },
    { script: 'hebrew', text: hebrew.split('').reverse().join(''), dir: 'rtl', label: '← עברית' },
  ];

  let html = '';
  layers.forEach((layer, idx) => {
    const dirClass = boustroMode ? (idx % 2 === 0 ? 'line-ltr' : 'line-rtl') : '';
    const temporalClass = temporalMode ? 'temporal-fragment' : '';
    const scriptClass = `script-${layer.script}`;

    // Build OLO-encoded characters
    let chars = '';
    for (const ch of layer.text) {
      if (ch === ' ') {
        chars += '&nbsp;&nbsp;';
      } else {
        // Determine if this char gets green or blue treatment
        // Consonants in green (structure), vowels/verification in blue
        const isBlueChar = 'αεηιουωאהוי'.includes(ch);
        if (isBlueChar) {
          chars += `<span class="olo-glyph"><span class="l-char">${ch}</span></span>`;
        } else {
          chars += `<span class="olo-glyph"><span class="o-char">${ch}</span></span>`;
        }
      }
    }

    html += `
      <div class="${dirClass} ${temporalClass}" style="margin: 8px 0; position: relative;">
        <span style="font-size: 8px; color: #333; letter-spacing: 2px;">${layer.label}</span><br>
        <span class="green-layer" style="position: relative; display: inline-block;">
          ${chars}
        </span>
      </div>
    `;
  });

  document.getElementById('render-output').innerHTML = html;

  // Live vs captured comparison
  const liveHtml = `
    <div style="font-size: 18px; letter-spacing: 2px; line-height: 2;">
      <span class="o-char" style="color: #00ff41;">${greek}</span><br>
      <span class="l-char" style="color: rgba(40,40,255,0.7);">${hebrew.split('').reverse().join('')}</span><br>
      <span style="color: #00dd33; font-size: 12px;">gematria: ${hebrewVal} → ${hebrewRed}</span>
    </div>
  `;
  document.getElementById('live-display').innerHTML = liveHtml;
  document.getElementById('captured-display').innerHTML = liveHtml;

  // Gematria panel
  document.getElementById('gematria-num').textContent = total;
  
  const maxVal = Math.max(greekVal, latinVal, hebrewVal);
  document.getElementById('gematria-bars').innerHTML = `
    <div class="gematria-bar" style="--green-pct: ${(greekVal/maxVal*100)}%"></div>
    <div class="explanation">Greek: ${greekVal} → ${greekRed} ${SEPHIROT[greekRed] || ''}</div>
    <div class="gematria-bar" style="--green-pct: ${(latinVal/maxVal*100)}%"></div>
    <div class="explanation">Latin: ${latinVal} → ${reduceToSingle(latinVal)} ${SEPHIROT[reduceToSingle(latinVal)] || ''}</div>
    <div class="gematria-bar" style="--green-pct: ${(hebrewVal/maxVal*100)}%"></div>
    <div class="explanation">Hebrew: ${hebrewVal} → ${hebrewRed} ${SEPHIROT[hebrewRed] || ''}</div>
  `;

  const nameIdx = (hebrewVal % 72) || 72;
  document.getElementById('gematria-info').textContent = 
    `Grand: ${total} → ${totalRed} ${SEPHIROT[totalRed] || ''} │ Name #${nameIdx} │ YHWH: ${hebrewVal} ÷ 26 = ${(hebrewVal/26).toFixed(2)}`;

  // Subpixel verification
  const subpixelStr = `${hebrew} ═ ${hebrewVal} ═ ${SEPHIROT[hebrewRed] || '?'} ═ `.repeat(8);
  document.getElementById('subpixel-output').textContent = subpixelStr;
}

function toggleTemporal() {
  temporalMode = !temporalMode;
  document.getElementById('btn-temporal').classList.toggle('active');
  render();
}

function toggleBoustro() {
  boustroMode = !boustroMode;
  document.getElementById('btn-boustro').classList.toggle('active');
  render();
}

function toggleDegrade() {
  degradeMode = !degradeMode;
  document.getElementById('btn-degrade').classList.toggle('active');
  document.getElementById('captured-box').style.display = degradeMode ? 'block' : 'block';
  
  // Apply degradation to main display too
  const main = document.getElementById('main-display');
  if (degradeMode) {
    main.classList.add('degraded');
  } else {
    main.classList.remove('degraded');
  }
}

// Enter key handler
document.getElementById('input').addEventListener('keydown', (e) => {
  if (e.key === 'Enter') render();
});

// Initial render
render();
</script>

</body>
</html>
